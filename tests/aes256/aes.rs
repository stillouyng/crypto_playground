
#[cfg(test)]
mod tests {
    use crypto_playground::encode::aes::AES;

    #[test]
    fn test_shift_rows() {
        let mut state = [
            [0x00, 0x01, 0x02, 0x03],
            [0x10, 0x11, 0x12, 0x13],
            [0x20, 0x21, 0x22, 0x23],
            [0x30, 0x31, 0x32, 0x33],
        ];
        let expected = [
            [0x00, 0x01, 0x02, 0x03],
            [0x11, 0x12, 0x13, 0x10],
            [0x22, 0x23, 0x20, 0x21],
            [0x33, 0x30, 0x31, 0x32],
        ];
        AES::new().shift_rows(&mut state);
        assert_eq!(state, expected);
    }

    #[test]
    fn test_mix_columns() {
        let aes = AES::new();

        let mut state1 = [
            [0x63, 0x63, 0x63, 0x63],
            [0x63, 0x63, 0x63, 0x63],
            [0x63, 0x63, 0x63, 0x63],
            [0x63, 0x63, 0x63, 0x63],
        ];
        let expected1 = state1.clone();
        aes.mix_columns(&mut state1);
        assert_eq!(state1, expected1);

        let mut state2 = [
            [0xDB, 0xF2, 0x01, 0x00],
            [0x13, 0x0A, 0x01, 0x00],
            [0x53, 0x22, 0x01, 0x00],
            [0x45, 0x5C, 0x01, 0x00],
        ];

        let expected2 = [
            [0x8E, 0x9F, 0x01, 0x00],
            [0x4D, 0xDC, 0x01, 0x00],
            [0xA1, 0x58, 0x01, 0x00],
            [0xBC, 0x9D, 0x01, 0x00],
        ];
        aes.mix_columns(&mut state2);
        assert_eq!(state2, expected2);
    }
}
